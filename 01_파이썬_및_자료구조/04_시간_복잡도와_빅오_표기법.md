# 시간 복잡도와 빅오 표기법

## 1. 알고리즘의 시간 복잡도

### 알고리즘의 소요 시간 측정
Input을 넣고 Output이 나올 때까지 몇 초가 걸리는지 직접 타이머로 측정한다면? <br>
개개인의 컴퓨팅 환경에 따라 같은 알고리즘이라도 측정 시간이 다름
<br>

 ⇒ 객관적인 측정을 위해 알고리즘 내부에서 연산 횟수 측정
> 알고리즘의 총 소요 시간 == 기본 연산의 총 횟수

\* 기본 연산: 단위 시간 1이 소요되는 연산 (ex: 할당, 산술, 비교, 반환, ...)

<br>
 
기본 연산의 횟수를 구하는 건 환경에 영향을 받지 않는 객관적인 방법이지만, <br>
입력의 개수에 따라 시간이 달라진다는 문제가 있음 
<br>

 ⇒ 성능을 측정할 때는 입력 통일
> 가장 기본 연산이 많이 일어나는 최악의 입력 n개가 들어온다고 가정

<br>
 
### 시간 복잡도 (Time Complexity)
~~계산 복잡도 이론에서 시간 복잡도는 문제를 해결하는데 걸리는 시간과 입력의 함수 관계를 가리킴~~
<br>

 ⇒ 단순하게 **알고리즘의 수행 시간**을 의미한다고 생각
> 시간 복잡도가 높으면 느린 알고리즘  <br>
> 시간 복잡도가 낮으면 빠른 알고리즘

<br>
 
동일한 기능을 제공하는 알고리즘에 대한 수행 시간이 각각 다음과 같다면,
> 1)  6n + 4
> 2) 3n + 2
> 3) 3n² + 6n + 1

1, 2)는 입력 n에 따른 시간 복잡도가 선형으로 증가 (일차함수) <br>
3)은 입력 n에 따른 시간 복잡도가 제곱으로 증가 (이차함수)
<br>

 ⇒ 포인트는 누가 빠른지 느린지가 아니라, 입력 n에 따른 수행 시간의 증가율

<br>

## 2. 빅오(Big-O) 표기법

### 빅오(Big-O) 표기법
입력 n이 무한대로 커진다고 가정하고 시간 복잡도를 간단하게 표시 <br>
최고차항만 남기고 계수와 상수 제거

> 1) 6n + 4 ⇒ O(n)
> 2) 3n + 2 ⇒ O(n)
> 3) 3n² + 6n + 1 ⇒ O(n²)

1, 2)는 원래 수행 시간이 2배 차이 났지만, <br>
증가율로 수행 시간을 따졌을 때는 동일한 O(n)의 시간 복잡도를 가짐
<br>

 ⇒ 증가율이 동일하므로 두 알고리즘의 성능이 비슷하다고 판단

<br>

### ※ 실제 문제에서 적용하는 방법
제한 시간과 입력을 통해 어느 정도의 시간 복잡도까지 허용되는지 어림짐작 가능 <br>
일반적으로 1초에 1억번 연산으로 가정
1. 제한 시간을 보고 가능한 총 연산 횟수 짐작 (제한 시간 x 1억)
2. 실제 입력의 가장 큰 범위에 따라 반복문을 몇 번까지 돌 수 있는지 계산
	1. 반복문 한번에 O(n), 이중 for문은 O(n²)
3. 가능한 총 연산 횟수를 넘어 시간 초과가 발생하면 풀이를 개선해야 함

